<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubo 3D Interativo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            padding: 10px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        Arraste o fundo para girar o cubo. Arraste uma face para mover as peças.
    </div>

    <!-- Importmap para Three.js e OrbitControls -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Variáveis Globais ---
        let scene, camera, renderer, controls;
        let cubeGroup, piecesGroup;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Estado da interação
        let isDragging = false;
        let dragStartPoint = { x: 0, y: 0 };
        let intersectedObject = null;
        let isAnimating = false;

        // --- Configuração Inicial ---
        function init() {
            // Cena
            scene = new THREE.Scene();
            
            // Câmera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 4, 6);
            camera.lookAt(scene.position);

            // Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controles de Órbita (para girar o cubo)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.rotateSpeed = 0.7;
            
            // Iluminação
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Criar o cubo
            createRubiksCube();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);

            // Iniciar loop de animação
            animate();
        }

        // --- Criação do Cubo ---
        function createRubiksCube() {
            cubeGroup = new THREE.Group();
            piecesGroup = new THREE.Group();
            cubeGroup.add(piecesGroup);

            const pieceSize = 1;
            const gap = 0.05;
            const totalSize = pieceSize + gap;

            // Adiciona o núcleo central para preencher os vãos
            const coreGeometry = new THREE.BoxGeometry(3, 3, 3);
            const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            cubeGroup.add(core);
            
            // Cores das faces do cubo mágico
            const colors = {
                front:  0xff0000, // Vermelho
                back:   0xffa500, // Laranja
                up:     0xffffff, // Branco
                down:   0xffff00, // Amarelo
                left:   0x0000ff, // Azul
                right:  0x00ff00  // Verde
            };

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        // Não cria a peça central invisível
                        if (x === 0 && y === 0 && z === 0) continue;

                        const materials = [
                            (x === 1) ? new THREE.MeshLambertMaterial({ color: colors.right }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c }), // right
                            (x === -1) ? new THREE.MeshLambertMaterial({ color: colors.left }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c }), // left
                            (y === 1) ? new THREE.MeshLambertMaterial({ color: colors.up }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c }), // up
                            (y === -1) ? new THREE.MeshLambertMaterial({ color: colors.down }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c }), // down
                            (z === 1) ? new THREE.MeshLambertMaterial({ color: colors.front }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c }), // front
                            (z === -1) ? new THREE.MeshLambertMaterial({ color: colors.back }) : new THREE.MeshLambertMaterial({ color: 0x1c1c1c })  // back
                        ];

                        const geometry = new THREE.BoxGeometry(pieceSize, pieceSize, pieceSize);
                        const piece = new THREE.Mesh(geometry, materials);
                        piece.position.set(x * totalSize, y * totalSize, z * totalSize);
                        piece.userData.originalPosition = piece.position.clone();
                        piecesGroup.add(piece);
                    }
                }
            }
            scene.add(cubeGroup);
        }

        // --- Lógica de Interação ---
        function onPointerDown(event) {
            if (isAnimating) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(piecesGroup.children);

            if (intersects.length > 0) {
                isDragging = true;
                controls.enabled = false;
                intersectedObject = {
                    object: intersects[0].object,
                    face: intersects[0].face
                };
                dragStartPoint = { x: event.clientX, y: event.clientY };
            }
        }

        function onPointerMove(event) {
            if (!isDragging || isAnimating) return;
            // A lógica de rotação acontece em onPointerUp para simplificar
        }

        function onPointerUp(event) {
            if (!isDragging || isAnimating) {
                controls.enabled = true;
                return;
            }

            const dragEndPoint = { x: event.clientX, y: event.clientY };
            const dragVector = { 
                x: dragEndPoint.x - dragStartPoint.x, 
                y: dragEndPoint.y - dragStartPoint.y 
            };

            // Se o arrasto for muito pequeno, ignora
            if (Math.abs(dragVector.x) < 10 && Math.abs(dragVector.y) < 10) {
                isDragging = false;
                controls.enabled = true;
                return;
            }
            
            determineAndRotateSlice(dragVector);

            isDragging = false;
            // Os controles serão reativados após a animação
        }

function determineAndRotateSlice(dragVector) {
    if (!intersectedObject) return;

    const piece = intersectedObject.object;
    const faceNormal = intersectedObject.face.normal.clone();

    // 1. Transformar a normal da face para o espaço do mundo
    const worldNormal = faceNormal.clone().transformDirection(piece.matrixWorld).round();

    // 2. Determinar a direção do arrasto no espaço da tela
    const screenDragVector = new THREE.Vector2(dragVector.x, dragVector.y).normalize();

    // 3. Determinar os eixos da câmera no espaço do mundo
    const cameraRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
    const cameraUp = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);

    // 4. Mapear o arrasto 2D da tela para um vetor de movimento 3D no mundo
    const worldDragVector = cameraRight.multiplyScalar(screenDragVector.x).add(
        cameraUp.multiplyScalar(-screenDragVector.y) // Y é invertido no espaço da tela
    ).normalize();

    // 5. Determinar o eixo de rotação
    // O eixo de rotação é perpendicular tanto à normal da face quanto à direção do arrasto no mundo
    let rotationAxis = new THREE.Vector3().crossVectors(worldNormal, worldDragVector).normalize();

    // 6. "Travar" o eixo ao eixo principal mais próximo (X, Y ou Z)
    const maxComponent = Math.max(Math.abs(rotationAxis.x), Math.abs(rotationAxis.y), Math.abs(rotationAxis.z));
    if (Math.abs(rotationAxis.x) === maxComponent) {
        rotationAxis.set(Math.sign(rotationAxis.x), 0, 0);
    } else if (Math.abs(rotationAxis.y) === maxComponent) {
        rotationAxis.set(0, Math.sign(rotationAxis.y), 0);
    } else {
        rotationAxis.set(0, 0, Math.sign(rotationAxis.z));
    }

    // 7. Determinar a direção (ângulo) da rotação
    // Projetamos o vetor de arrasto mundial no plano perpendicular ao eixo de rotação
    // e verificamos se ele está alinhado com a normal da face (ou oposto a ela)
    const projectedDrag = worldDragVector.clone();
    const cross = new THREE.Vector3().crossVectors(rotationAxis, worldNormal);
    const dot = projectedDrag.dot(cross);
    const angle = (Math.PI / 2) * Math.sign(dot);


    // 8. Obter a fatia e animar
    const slice = getSlice(rotationAxis, piece.position);
    if (slice.length > 0) {
        animateRotation(slice, rotationAxis, angle);
    } else {
        // Se nenhuma fatia for encontrada, reativa os controles
        controls.enabled = true;
    }
}

        function getSlice(axis, position) {
            const slice = [];
            piecesGroup.children.forEach(child => {
                if (Math.abs(child.position.dot(axis) - position.dot(axis)) < 0.1) {
                    slice.push(child);
                }
            });
            return slice;
        }

        function animateRotation(slice, axis, angle) {
            if (isAnimating) return;
            isAnimating = true;

            const pivot = new THREE.Group();
            scene.add(pivot);

            slice.forEach(piece => {
                pivot.attach(piece);
            });

            const duration = 300; // ms
            const startTime = Date.now();
            
            function step() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Ease-out-quad
                const easedProgress = progress * (2 - progress);
                
                pivot.setRotationFromAxisAngle(axis, angle * easedProgress);

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    // Finaliza a rotação
                    pivot.setRotationFromAxisAngle(axis, angle);
                    
                    // Reposiciona as peças de volta no grupo principal
                    while(pivot.children.length > 0) {
                        const piece = pivot.children[0];
                        // Atualiza a matriz do objeto antes de re-anexar
                        piece.updateMatrixWorld();
                        cubeGroup.attach(piece);
                        // Arredonda a posição para evitar erros de ponto flutuante
                        piece.position.round();
                    }
                    
                    scene.remove(pivot);
                    isAnimating = false;
                    controls.enabled = true; // Reativa os controles
                }
            }
            requestAnimationFrame(step);
        }

        // --- Funções Utilitárias ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Loop de Animação ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Iniciar ---
        init();

    </script>
</body>
</html>
