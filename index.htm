<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubo Mágico 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { display: block; width: 100%; height: calc(100vh - 80px); background-color: #f3f4f6; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .button-container { display: flex; justify-content: center; align-items: center; gap: 1rem; padding: 1rem; padding-bottom: calc(2.5rem + env(safe-area-inset-bottom)); background-color: #e5e7eb; border-top: 1px solid #d1d5db; }
        .button { color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem; font-weight: bold; transition: background-color 0.3s ease, transform 0.1s ease; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .shuffle-button { background-color: #4CAF50; }
        .solve-button { background-color: #3b82f6; }
        .button:hover { transform: translateY(-2px); }
        .button:active { transform: translateY(0); }
        .shuffle-button:hover { background-color: #45a049; }
        .solve-button:hover { background-color: #2563eb; }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-200">
    <div class="flex-grow flex justify-center items-center p-4">
        <canvas id="cubeCanvas"></canvas>
    </div>
    <div class="button-container">
        <button id="shuffleButton" class="button shuffle-button">Embaralhar</button>
        <button id="solveButton" class="button solve-button">Resolver</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cubeGroup, cubies = [];
        const CUBE_SIZE = 3, CUBIE_SPACING = 0.1, CUBIE_SIZE_VAL = 1;

        let isDragging = false, isAnimating = false;
        let previousMousePosition = { x: 0, y: 0 };
        let intersectedCubie = null, intersectedFaceNormal = null;

        let rotationPivot = new THREE.Group();

        const colors = { R: 0xFF0000, G: 0x00FF00, B: 0x0000FF, Y: 0xFFFF00, W: 0xFFFFFF, O: 0xFFA500, D: 0x222222 };

        let activeRotation = null;
        const ROTATION_DURATION = 150; // Duração da animação em ms

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 1000);
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('cubeCanvas'), alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 80);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);

            scene.add(new THREE.AmbientLight(0x606060, 3));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            scene.add(rotationPivot);
            createCube();
            addEventListeners();
            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        function createCube() {
            cubeGroup = new THREE.Group();
            const offset = (CUBE_SIZE - 1) / 2;
            for (let x = 0; x < CUBE_SIZE; x++) {
                for (let y = 0; y < CUBE_SIZE; y++) {
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        const geometry = new THREE.BoxGeometry(CUBIE_SIZE_VAL, CUBIE_SIZE_VAL, CUBIE_SIZE_VAL);
                        const materials = [
                            new THREE.MeshLambertMaterial({ color: (x === CUBE_SIZE - 1) ? colors.R : colors.D }),
                            new THREE.MeshLambertMaterial({ color: (x === 0) ? colors.O : colors.D }),
                            new THREE.MeshLambertMaterial({ color: (y === CUBE_SIZE - 1) ? colors.Y : colors.D }),
                            new THREE.MeshLambertMaterial({ color: (y === 0) ? colors.W : colors.D }),
                            new THREE.MeshLambertMaterial({ color: (z === CUBE_SIZE - 1) ? colors.G : colors.D }),
                            new THREE.MeshLambertMaterial({ color: (z === 0) ? colors.B : colors.D })
                        ];
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(
                            (x - offset) * (CUBIE_SIZE_VAL + CUBIE_SPACING),
                            (y - offset) * (CUBIE_SIZE_VAL + CUBIE_SPACING),
                            (z - offset) * (CUBIE_SIZE_VAL + CUBIE_SPACING)
                        );
                        cubies.push(cubie);
                        cubeGroup.add(cubie);
                    }
                }
            }
            scene.add(cubeGroup);
        }

        function addEventListeners() {
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('mouseleave', onMouseUp, false);
            document.getElementById('solveButton').addEventListener('click', () => alert('Funcionalidade de resolver ainda não implementada.'));
            document.getElementById('shuffleButton').addEventListener('click', () => alert('Funcionalidade de embaralhar ainda não implementada.'));
        }

        function onMouseDown(event) {
            if (isAnimating) return;
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
            const mouse = new THREE.Vector2((event.clientX / renderer.domElement.clientWidth) * 2 - 1, -(event.clientY / renderer.domElement.clientHeight) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubies);
            if (intersects.length > 0) {
                intersectedCubie = intersects[0].object;
                intersectedFaceNormal = intersects[0].face.normal.clone().transformDirection(intersectedCubie.matrixWorld);
            } else {
                intersectedCubie = null;
            }
        }

        function onMouseMove(event) {
            if (!isDragging || isAnimating) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            if (!intersectedCubie) {
                const rotationSpeed = 0.005;
                const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(deltaY * rotationSpeed, deltaX * rotationSpeed, 0, 'YXZ'));
                cubeGroup.quaternion.multiplyQuaternions(deltaRotationQuaternion, cubeGroup.quaternion);
            } else {
                const threshold = 15;
                if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                    const cameraRight = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
                    const cameraUp = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
                    const worldDragVector = cameraRight.multiplyScalar(deltaX).add(cameraUp.multiplyScalar(deltaY));
                    const dragOnFacePlane = worldDragVector.clone().sub(intersectedFaceNormal.clone().multiplyScalar(worldDragVector.dot(intersectedFaceNormal)));
                    let tempRotationAxis = new THREE.Vector3().crossVectors(intersectedFaceNormal, dragOnFacePlane).normalize();

                    let axis = new THREE.Vector3();
                    const absX = Math.abs(tempRotationAxis.x), absY = Math.abs(tempRotationAxis.y), absZ = Math.abs(tempRotationAxis.z);
                    if (absX > absY && absX > absZ) axis.set(Math.sign(tempRotationAxis.x), 0, 0);
                    else if (absY > absX && absY > absZ) axis.set(0, Math.sign(tempRotationAxis.y), 0);
                    else axis.set(0, 0, Math.sign(tempRotationAxis.z));

                    const angle = -(Math.PI / 2) * Math.sign(axis.dot(tempRotationAxis));
                    startSliceRotation(intersectedCubie, axis.applyQuaternion(cubeGroup.quaternion.clone().invert()), angle);
                    isDragging = false;
                }
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() { isDragging = false; intersectedCubie = null; }

        function startSliceRotation(cubie, axis, angle) {
            if (isAnimating) return;
            isAnimating = true;

            const rotatingSlice = cubies.filter(c => Math.abs(c.position.dot(axis)) < 0.1);

            rotationPivot.quaternion.identity();
            rotationPivot.position.set(0,0,0);

            rotatingSlice.forEach(c => rotationPivot.add(c));

            const startQuaternion = new THREE.Quaternion();
            const targetQuaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            let startTime = null;

            const animateRotation = (time) => {
                if (startTime === null) startTime = time;
                const progress = Math.min((time - startTime) / ROTATION_DURATION, 1);

                THREE.Quaternion.slerp(startQuaternion, targetQuaternion, rotationPivot.quaternion, progress);

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    rotatingSlice.forEach(c => {
                        c.position.applyQuaternion(targetQuaternion);
                        c.quaternion.multiplyQuaternions(targetQuaternion, c.quaternion);
                        cubeGroup.add(c);
                    });
                    rotationPivot.clear();
                    isAnimating = false;
                }
            };
            requestAnimationFrame(animateRotation);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / (window.innerHeight - 80);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 80);
        }

        init();
    </script>
</body>
</html>